/**\n * Test suite for Chrome API Safety utilities\n * Tests circuit breakers, retry mechanisms, and error handling\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport {\n  isExtensionContextValid,\n  safeStorageGet,\n  safeStorageSet,\n  safeSendMessage,\n  getCircuitBreakerStats,\n  resetCircuitBreakers,\n  getChromeApiSafetyStats\n} from '@utils/chromeApiSafe.js'\n\ndescribe('Chrome API Safety', () => {\n  beforeEach(() => {\n    // Reset all mocks and circuit breakers\n    testUtils.resetChromeMocks()\n    resetCircuitBreakers()\n    vi.clearAllTimers()\n  })\n  \n  describe('isExtensionContextValid', () => {\n    it('should return true when Chrome APIs are available', () => {\n      expect(isExtensionContextValid()).toBe(true)\n    })\n    \n    it('should return false when chrome.runtime.id is missing', () => {\n      delete chrome.runtime.id\n      expect(isExtensionContextValid()).toBe(false)\n      \n      // Restore for other tests\n      chrome.runtime.id = 'test-extension-id'\n    })\n    \n    it('should return false when chrome.storage is missing', () => {\n      delete chrome.storage\n      expect(isExtensionContextValid()).toBe(false)\n      \n      // Restore for other tests\n      chrome.storage = {\n        local: { get: vi.fn(), set: vi.fn() },\n        sync: { get: vi.fn(), set: vi.fn() }\n      }\n    })\n  })\n  \n  describe('safeStorageGet', () => {\n    it('should successfully get storage data', async () => {\n      const testData = { key1: 'value1', key2: 'value2' }\n      testUtils.mockChromeStorageSuccess(testData)\n      \n      const result = await safeStorageGet(['key1', 'key2'])\n      expect(result).toEqual({ key1: 'value1', key2: 'value2' })\n    })\n    \n    it('should handle single key requests', async () => {\n      const testData = { singleKey: 'singleValue' }\n      testUtils.mockChromeStorageSuccess(testData)\n      \n      const result = await safeStorageGet('singleKey')\n      expect(result).toEqual({ singleKey: 'singleValue' })\n    })\n    \n    it('should retry on retryable errors', async () => {\n      let callCount = 0\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        callCount++\n        if (callCount < 3) {\n          chrome.runtime.lastError = new Error('temporarily unavailable')\n          callback(null)\n        } else {\n          chrome.runtime.lastError = null\n          callback({ test: 'success' })\n        }\n      })\n      \n      const result = await safeStorageGet('test')\n      expect(result).toEqual({ test: 'success' })\n      expect(callCount).toBe(3)\n    })\n    \n    it('should not retry on non-retryable errors', async () => {\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        chrome.runtime.lastError = new Error('extension context invalidated')\n        callback(null)\n      })\n      \n      await expect(safeStorageGet('test')).rejects.toThrow('extension context invalidated')\n      expect(chrome.storage.local.get).toHaveBeenCalledTimes(1)\n    })\n    \n    it('should work with callback interface', (done) => {\n      testUtils.mockChromeStorageSuccess({ test: 'callback-value' })\n      \n      safeStorageGet('test', (result, error) => {\n        expect(error).toBeNull()\n        expect(result).toEqual({ test: 'callback-value' })\n        done()\n      })\n    })\n    \n    it('should handle extension context invalidation gracefully', async () => {\n      // Mock invalid context\n      chrome.runtime.id = undefined\n      \n      await expect(safeStorageGet('test')).rejects.toThrow('Extension context invalidated')\n      \n      // Restore for other tests\n      chrome.runtime.id = 'test-extension-id'\n    })\n  })\n  \n  describe('safeStorageSet', () => {\n    it('should successfully set storage data', async () => {\n      const testData = { key1: 'value1', key2: 'value2' }\n      testUtils.mockChromeStorageSuccess()\n      \n      await expect(safeStorageSet(testData)).resolves.toBeUndefined()\n      expect(chrome.storage.local.set).toHaveBeenCalledWith(testData, expect.any(Function))\n    })\n    \n    it('should validate writes when requested', async () => {\n      const testData = { validated: 'data' }\n      \n      // Mock successful set and get for validation\n      chrome.storage.local.set.mockImplementation((items, callback) => {\n        callback()\n      })\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        callback(testData)\n      })\n      \n      await expect(\n        safeStorageSet(testData, { validateWrite: true })\n      ).resolves.toBeUndefined()\n    })\n    \n    it('should detect validation failures', async () => {\n      const testData = { original: 'data' }\n      const corruptedData = { original: 'corrupted' }\n      \n      chrome.storage.local.set.mockImplementation((items, callback) => {\n        callback()\n      })\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        callback(corruptedData) // Return different data\n      })\n      \n      // Should still resolve (graceful degradation) but log error\n      await expect(\n        safeStorageSet(testData, { validateWrite: true })\n      ).resolves.toBeUndefined()\n    })\n    \n    it('should retry with exponential backoff', async () => {\n      let callCount = 0\n      const delays = []\n      const originalSetTimeout = global.setTimeout\n      \n      global.setTimeout = vi.fn((callback, delay) => {\n        delays.push(delay)\n        return originalSetTimeout(callback, 0) // Execute immediately for test\n      })\n      \n      chrome.storage.local.set.mockImplementation((items, callback) => {\n        callCount++\n        if (callCount < 3) {\n          chrome.runtime.lastError = new Error('quota exceeded')\n        } else {\n          chrome.runtime.lastError = null\n        }\n        callback()\n      })\n      \n      await safeStorageSet({ test: 'retry' })\n      \n      expect(callCount).toBe(3)\n      expect(delays.length).toBe(2) // Two retries\n      expect(delays[1]).toBeGreaterThan(delays[0]) // Exponential backoff\n      \n      global.setTimeout = originalSetTimeout\n    })\n    \n    it('should handle oversized items', async () => {\n      const oversizedItem = {\n        huge: 'x'.repeat(10000) // Exceeds default limit\n      }\n      \n      testUtils.mockChromeStorageSuccess()\n      \n      await expect(\n        safeStorageSet(oversizedItem, { maxItemSize: 100 })\n      ).resolves.toBeUndefined()\n      \n      // Should still attempt to store but log warning\n    })\n  })\n  \n  describe('safeSendMessage', () => {\n    it('should send messages successfully', async () => {\n      const testMessage = { action: 'test', data: 'hello' }\n      const mockResponse = { success: true }\n      \n      chrome.runtime.sendMessage.mockImplementation((message, callback) => {\n        callback(mockResponse)\n      })\n      \n      const result = await safeSendMessage(testMessage)\n      expect(result).toEqual(mockResponse)\n      expect(chrome.runtime.sendMessage).toHaveBeenCalledWith(\n        testMessage,\n        expect.any(Function)\n      )\n    })\n    \n    it('should retry on retryable message errors', async () => {\n      let callCount = 0\n      chrome.runtime.sendMessage.mockImplementation((message, callback) => {\n        callCount++\n        if (callCount < 3) {\n          chrome.runtime.lastError = new Error('network error')\n          callback(null)\n        } else {\n          chrome.runtime.lastError = null\n          callback({ success: true })\n        }\n      })\n      \n      const result = await safeSendMessage({ action: 'retry-test' })\n      expect(result).toEqual({ success: true })\n      expect(callCount).toBe(3)\n    })\n    \n    it('should work with callback interface', (done) => {\n      const testMessage = { action: 'callback-test' }\n      const mockResponse = { received: true }\n      \n      chrome.runtime.sendMessage.mockImplementation((message, callback) => {\n        callback(mockResponse)\n      })\n      \n      safeSendMessage(testMessage, (result, error) => {\n        expect(error).toBeNull()\n        expect(result).toEqual(mockResponse)\n        done()\n      })\n    })\n  })\n  \n  describe('Circuit Breaker Integration', () => {\n    it('should track circuit breaker statistics', () => {\n      const stats = getCircuitBreakerStats()\n      \n      expect(stats).toHaveProperty('storage')\n      expect(stats).toHaveProperty('messaging')\n      expect(stats.storage).toHaveProperty('state')\n      expect(stats.storage).toHaveProperty('failures')\n      expect(stats.storage).toHaveProperty('recentOperations')\n    })\n    \n    it('should open circuit breaker after failures', async () => {\n      // Mock repeated failures\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        chrome.runtime.lastError = new Error('storage failed')\n        callback(null)\n      })\n      \n      // Trigger multiple failures to open circuit\n      for (let i = 0; i < 6; i++) {\n        try {\n          await safeStorageGet('test', null, { useCircuitBreaker: true })\n        } catch (e) {\n          // Expected to fail\n        }\n      }\n      \n      const stats = getCircuitBreakerStats()\n      expect(stats.storage.state).toBe('open')\n    })\n    \n    it('should reset circuit breakers', () => {\n      resetCircuitBreakers()\n      \n      const stats = getCircuitBreakerStats()\n      Object.values(stats).forEach(breakerStats => {\n        expect(breakerStats.state).toBe('closed')\n        expect(breakerStats.failures).toBe(0)\n      })\n    })\n    \n    it('should provide comprehensive safety statistics', () => {\n      const stats = getChromeApiSafetyStats()\n      \n      expect(stats).toHaveProperty('contextValid')\n      expect(stats).toHaveProperty('circuitBreakers')\n      expect(stats).toHaveProperty('timestamp')\n      expect(typeof stats.contextValid).toBe('boolean')\n      expect(typeof stats.timestamp).toBe('string')\n    })\n  })\n  \n  describe('Error Classification', () => {\n    // Note: Error classification is internal, so we test it through behavior\n    \n    it('should classify context errors as non-retryable', async () => {\n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        chrome.runtime.lastError = new Error('extension context invalidated')\n        callback(null)\n      })\n      \n      await expect(safeStorageGet('test')).rejects.toThrow()\n      expect(chrome.storage.local.get).toHaveBeenCalledTimes(1) // No retries\n    })\n    \n    it('should classify quota errors as retryable with longer delays', async () => {\n      let callCount = 0\n      const delays = []\n      const originalSetTimeout = global.setTimeout\n      \n      global.setTimeout = vi.fn((callback, delay) => {\n        delays.push(delay)\n        return originalSetTimeout(callback, 0)\n      })\n      \n      chrome.storage.local.get.mockImplementation((keys, callback) => {\n        callCount++\n        if (callCount === 1) {\n          chrome.runtime.lastError = new Error('quota exceeded')\n        } else {\n          chrome.runtime.lastError = null\n        }\n        callback(callCount === 1 ? null : { test: 'success' })\n      })\n      \n      await safeStorageGet('test')\n      \n      expect(callCount).toBe(2)\n      expect(delays.length).toBeGreaterThan(0)\n      \n      global.setTimeout = originalSetTimeout\n    })\n    \n    it('should classify network errors as retryable', async () => {\n      let callCount = 0\n      chrome.runtime.sendMessage.mockImplementation((message, callback) => {\n        callCount++\n        if (callCount === 1) {\n          chrome.runtime.lastError = new Error('network timeout')\n        } else {\n          chrome.runtime.lastError = null\n        }\n        callback(callCount === 1 ? null : { success: true })\n      })\n      \n      const result = await safeSendMessage({ action: 'network-test' })\n      \n      expect(result).toEqual({ success: true })\n      expect(callCount).toBe(2)\n    })\n  })\n  \n  describe('Performance and Memory', () => {\n    it('should not leak memory during retries', async () => {\n      // This test ensures no memory leaks during retry operations\n      const initialMemory = performance.memory?.usedJSHeapSize || 0\n      \n      // Perform many retry operations\n      for (let i = 0; i < 100; i++) {\n        chrome.storage.local.get.mockImplementation((keys, callback) => {\n          chrome.runtime.lastError = new Error('extension context invalidated')\n          callback(null)\n        })\n        \n        try {\n          await safeStorageGet(`key-${i}`)\n        } catch (e) {\n          // Expected to fail\n        }\n      }\n      \n      const finalMemory = performance.memory?.usedJSHeapSize || 0\n      \n      // Memory usage should not grow significantly\n      // Note: This is a rough test and may not be perfectly reliable\n      const memoryGrowth = finalMemory - initialMemory\n      expect(memoryGrowth).toBeLessThan(1000000) // Less than 1MB growth\n    })\n    \n    it('should handle high concurrency gracefully', async () => {\n      testUtils.mockChromeStorageSuccess({ concurrent: 'test' })\n      \n      // Run many concurrent operations\n      const promises = []\n      for (let i = 0; i < 50; i++) {\n        promises.push(safeStorageGet(`concurrent-${i}`))\n      }\n      \n      const results = await Promise.all(promises)\n      expect(results).toHaveLength(50)\n      results.forEach(result => {\n        expect(result).toHaveProperty('concurrent')\n      })\n    })\n  })\n})"