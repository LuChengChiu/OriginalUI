/**\n * Test suite for ElementRemover module\n * Tests DOM manipulation, cleanup tracking, and memory management\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { ElementRemover } from '@modules/ElementRemover.js'\n\ndescribe('ElementRemover', () => {\n  let mockElements\n  \n  beforeEach(() => {\n    // Reset ElementRemover state\n    ElementRemover.cleanup()\n    \n    // Create mock DOM elements\n    mockElements = [\n      testUtils.createMockElement('div'),\n      testUtils.createMockElement('span'),\n      testUtils.createMockElement('iframe')\n    ]\n    \n    // Add some basic properties\n    mockElements[0].className = 'test-ad'\n    mockElements[1].textContent = 'Advertisement'\n    mockElements[2].src = 'https://ads.example.com'\n  })\n  \n  afterEach(() => {\n    // Clean up after each test\n    ElementRemover.cleanup()\n  })\n  \n  describe('REMOVAL_STRATEGIES', () => {\n    it('should have correct strategy constants', () => {\n      expect(ElementRemover.REMOVAL_STRATEGIES.HIDE).toBe('hide')\n      expect(ElementRemover.REMOVAL_STRATEGIES.REMOVE).toBe('remove')\n      expect(ElementRemover.REMOVAL_STRATEGIES.NEUTRALIZE).toBe('neutralize')\n    })\n  })\n  \n  describe('removeElement', () => {\n    it('should remove element with REMOVE strategy', () => {\n      const element = mockElements[0]\n      const result = ElementRemover.removeElement(\n        element, \n        'test-rule', \n        ElementRemover.REMOVAL_STRATEGIES.REMOVE\n      )\n      \n      expect(result).toBe(true)\n      expect(element.remove).toHaveBeenCalled()\n      expect(element.getAttribute('data-justui-removed')).toBe('test-rule')\n      expect(element.getAttribute('data-justui-strategy')).toBe('remove')\n    })\n    \n    it('should hide element with HIDE strategy', () => {\n      const element = mockElements[0]\n      const result = ElementRemover.removeElement(\n        element,\n        'hide-rule',\n        ElementRemover.REMOVAL_STRATEGIES.HIDE\n      )\n      \n      expect(result).toBe(true)\n      expect(element.style.display).toBe('none')\n      expect(element.style.visibility).toBe('hidden')\n      expect(element.remove).not.toHaveBeenCalled()\n    })\n    \n    it('should neutralize element with NEUTRALIZE strategy', () => {\n      const element = mockElements[2] // iframe\n      const result = ElementRemover.removeElement(\n        element,\n        'neutralize-rule',\n        ElementRemover.REMOVAL_STRATEGIES.NEUTRALIZE\n      )\n      \n      expect(result).toBe(true)\n      expect(element.style.pointerEvents).toBe('none')\n      expect(element.style.userSelect).toBe('none')\n      expect(element.style.visibility).toBe('hidden')\n      expect(element.style.opacity).toBe('0')\n      expect(element.src).toBe('about:blank')\n    })\n    \n    it('should not process already processed elements', () => {\n      const element = mockElements[0]\n      \n      // First removal\n      const result1 = ElementRemover.removeElement(element, 'rule1')\n      expect(result1).toBe(true)\n      \n      // Second attempt should be ignored\n      const result2 = ElementRemover.removeElement(element, 'rule2')\n      expect(result2).toBe(false)\n    })\n    \n    it('should handle null or undefined elements', () => {\n      expect(ElementRemover.removeElement(null, 'test')).toBe(false)\n      expect(ElementRemover.removeElement(undefined, 'test')).toBe(false)\n    })\n    \n    it('should handle errors during removal gracefully', () => {\n      const element = mockElements[0]\n      \n      // Mock setAttribute to throw error\n      element.setAttribute = vi.fn(() => {\n        throw new Error('DOM error')\n      })\n      \n      const result = ElementRemover.removeElement(element, 'error-test')\n      \n      // Should still succeed despite attribute error\n      expect(result).toBe(true)\n      expect(element.remove).toHaveBeenCalled()\n    })\n    \n    it('should prevent removal of critical elements', () => {\n      const criticalElement = testUtils.createMockElement('body')\n      \n      const result = ElementRemover.removeElement(\n        criticalElement,\n        'critical-test',\n        ElementRemover.REMOVAL_STRATEGIES.REMOVE\n      )\n      \n      // Should fallback to neutralization instead of removal\n      expect(result).toBe(true)\n      expect(criticalElement.remove).not.toHaveBeenCalled()\n      expect(criticalElement.style.pointerEvents).toBe('none')\n    })\n  })\n  \n  describe('isProcessed', () => {\n    it('should correctly identify processed elements', () => {\n      const element = mockElements[0]\n      \n      expect(ElementRemover.isProcessed(element)).toBe(false)\n      \n      ElementRemover.removeElement(element, 'test')\n      \n      expect(ElementRemover.isProcessed(element)).toBe(true)\n    })\n    \n    it('should handle null elements', () => {\n      expect(ElementRemover.isProcessed(null)).toBe(false)\n    })\n  })\n  \n  describe('batchRemove', () => {\n    it('should remove multiple elements and return count', () => {\n      const result = ElementRemover.batchRemove(\n        mockElements,\n        'batch-rule',\n        ElementRemover.REMOVAL_STRATEGIES.HIDE\n      )\n      \n      expect(result).toBe(3)\n      mockElements.forEach(element => {\n        expect(element.style.display).toBe('none')\n        expect(element.style.visibility).toBe('hidden')\n      })\n    })\n    \n    it('should skip already processed elements in batch', () => {\n      // Pre-process one element\n      ElementRemover.removeElement(mockElements[0], 'pre-rule')\n      \n      const result = ElementRemover.batchRemove(\n        mockElements,\n        'batch-rule'\n      )\n      \n      expect(result).toBe(2) // Only 2 new elements processed\n    })\n    \n    it('should handle empty arrays', () => {\n      const result = ElementRemover.batchRemove([], 'empty-batch')\n      expect(result).toBe(0)\n    })\n    \n    it('should handle arrays with null elements', () => {\n      const mixedArray = [mockElements[0], null, mockElements[1], undefined]\n      const result = ElementRemover.batchRemove(mixedArray, 'mixed-batch')\n      \n      expect(result).toBe(2) // Only valid elements processed\n    })\n  })\n  \n  describe('neutralizeElement', () => {\n    it('should neutralize regular elements', () => {\n      const element = mockElements[0]\n      ElementRemover.neutralizeElement(element)\n      \n      expect(element.style.pointerEvents).toBe('none')\n      expect(element.style.userSelect).toBe('none')\n      expect(element.style.visibility).toBe('hidden')\n      expect(element.style.opacity).toBe('0')\n      expect(element.style.zIndex).toBe('-9999')\n    })\n    \n    it('should handle iframe elements specially', () => {\n      const iframe = mockElements[2]\n      iframe.src = 'https://malicious.com'\n      \n      ElementRemover.neutralizeElement(iframe)\n      \n      expect(iframe.src).toBe('about:blank')\n      expect(iframe.getAttribute('data-justui-original-src')).toBe('https://malicious.com')\n      expect(iframe.getAttribute('sandbox')).toBe('')\n    })\n    \n    it('should disable form elements', () => {\n      const input = testUtils.createMockElement('input')\n      const button = testUtils.createMockElement('button')\n      const select = testUtils.createMockElement('select')\n      \n      input.disabled = false\n      button.disabled = false\n      select.disabled = false\n      \n      ElementRemover.neutralizeElement(input)\n      ElementRemover.neutralizeElement(button)\n      ElementRemover.neutralizeElement(select)\n      \n      expect(input.disabled).toBe(true)\n      expect(button.disabled).toBe(true)\n      expect(select.disabled).toBe(true)\n    })\n    \n    it('should remove dangerous attributes', () => {\n      const element = mockElements[0]\n      element.setAttribute('onclick', 'alert(\"dangerous\")')\n      element.setAttribute('onmouseover', 'steal_data()')\n      element.setAttribute('onload', 'malware()')\n      \n      ElementRemover.neutralizeElement(element)\n      \n      expect(element.hasAttribute('onclick')).toBe(false)\n      expect(element.hasAttribute('onmouseover')).toBe(false)\n      expect(element.hasAttribute('onload')).toBe(false)\n    })\n    \n    it('should store original styles for restoration', () => {\n      const element = mockElements[0]\n      element.style.opacity = '0.5'\n      element.style.zIndex = '100'\n      \n      ElementRemover.neutralizeElement(element)\n      \n      const originalStyles = element.getAttribute('data-justui-original-styles')\n      expect(originalStyles).toBeTruthy()\n      \n      const parsed = JSON.parse(originalStyles)\n      expect(parsed.opacity).toBe('0.5')\n      expect(parsed.zIndex).toBe('100')\n    })\n    \n    it('should handle errors during neutralization gracefully', () => {\n      const element = mockElements[0]\n      \n      // Mock style assignment to throw error\n      Object.defineProperty(element, 'style', {\n        get: () => {\n          throw new Error('Style error')\n        },\n        set: () => {\n          throw new Error('Style error')\n        }\n      })\n      \n      // Should not throw despite errors\n      expect(() => {\n        ElementRemover.neutralizeElement(element)\n      }).not.toThrow()\n    })\n  })\n  \n  describe('restoreElement', () => {\n    it('should restore neutralized elements', () => {\n      const element = mockElements[0]\n      element.style.opacity = '1'\n      element.style.zIndex = '5'\n      \n      // Neutralize first\n      ElementRemover.neutralizeElement(element)\n      \n      // Then restore\n      const result = ElementRemover.restoreElement(element)\n      \n      expect(result).toBe(true)\n      expect(element.style.opacity).toBe('1')\n      expect(element.style.zIndex).toBe('5')\n    })\n    \n    it('should restore iframe src', () => {\n      const iframe = mockElements[2]\n      iframe.src = 'https://legitimate.com'\n      \n      ElementRemover.neutralizeElement(iframe)\n      expect(iframe.src).toBe('about:blank')\n      \n      ElementRemover.restoreElement(iframe)\n      expect(iframe.src).toBe('https://legitimate.com')\n    })\n    \n    it('should re-enable form elements', () => {\n      const input = testUtils.createMockElement('input')\n      input.disabled = false\n      \n      ElementRemover.neutralizeElement(input)\n      expect(input.disabled).toBe(true)\n      \n      ElementRemover.restoreElement(input)\n      expect(input.disabled).toBe(false)\n    })\n    \n    it('should handle elements without stored state', () => {\n      const element = mockElements[0]\n      \n      // Try to restore without neutralizing first\n      const result = ElementRemover.restoreElement(element)\n      \n      // Should handle gracefully\n      expect(result).toBe(true)\n    })\n    \n    it('should handle restoration errors gracefully', () => {\n      const element = mockElements[0]\n      \n      // Create invalid JSON in original styles\n      element.setAttribute('data-justui-original-styles', 'invalid-json')\n      \n      const result = ElementRemover.restoreElement(element)\n      expect(result).toBe(false)\n    })\n  })\n  \n  describe('getStats', () => {\n    it('should return comprehensive statistics', () => {\n      // Process some elements to generate stats\n      ElementRemover.removeElement(mockElements[0], 'test1', 'hide')\n      ElementRemover.removeElement(mockElements[1], 'test2', 'remove')\n      ElementRemover.removeElement(mockElements[2], 'test3', 'neutralize')\n      \n      const stats = ElementRemover.getStats()\n      \n      expect(stats.removalStats.totalRemoved).toBe(3)\n      expect(stats.removalStats.strategyCounts.hide).toBe(1)\n      expect(stats.removalStats.strategyCounts.remove).toBe(1)\n      expect(stats.removalStats.strategyCounts.neutralize).toBe(1)\n      \n      expect(stats.performance.mostUsedStrategy).toBeTruthy()\n      expect(stats.cleanupState.registeredCallbacks).toBe(0)\n    })\n    \n    it('should calculate performance metrics', () => {\n      // Generate some activity\n      for (let i = 0; i < 10; i++) {\n        const element = testUtils.createMockElement('div')\n        ElementRemover.removeElement(element, `perf-test-${i}`)\n      }\n      \n      const stats = ElementRemover.getStats()\n      \n      expect(stats.performance.averageRemovalsPerMinute).toBeTruthy()\n      expect(parseFloat(stats.performance.averageRemovalsPerMinute)).toBeGreaterThan(0)\n    })\n    \n    it('should format duration strings correctly', () => {\n      // Test the formatDuration method indirectly through stats\n      const stats = ElementRemover.getStats()\n      \n      expect(stats.removalStats.cacheAgeHuman).toMatch(/\\d+(\\.\\d+)?(ms|s|m|h)/)\n    })\n  })\n  \n  describe('cleanup callbacks', () => {\n    it('should register and notify cleanup callbacks', () => {\n      const callback = vi.fn()\n      ElementRemover.onCleanup(callback)\n      \n      ElementRemover.removeElement(mockElements[0], 'callback-test')\n      \n      expect(callback).toHaveBeenCalledWith(\n        'element_removed',\n        expect.objectContaining({\n          element: mockElements[0],\n          ruleId: 'callback-test'\n        })\n      )\n    })\n    \n    it('should handle callback errors gracefully', () => {\n      const faultyCallback = vi.fn(() => {\n        throw new Error('Callback error')\n      })\n      const goodCallback = vi.fn()\n      \n      ElementRemover.onCleanup(faultyCallback)\n      ElementRemover.onCleanup(goodCallback)\n      \n      // Should not throw despite faulty callback\n      expect(() => {\n        ElementRemover.removeElement(mockElements[0], 'error-test')\n      }).not.toThrow()\n      \n      expect(goodCallback).toHaveBeenCalled()\n    })\n    \n    it('should remove callback listeners', () => {\n      const callback = vi.fn()\n      ElementRemover.onCleanup(callback)\n      ElementRemover.offCleanup(callback)\n      \n      ElementRemover.removeElement(mockElements[0], 'removed-callback')\n      \n      expect(callback).not.toHaveBeenCalled()\n    })\n  })\n  \n  describe('cleanup and memory management', () => {\n    it('should reset all statistics on cleanup', () => {\n      // Generate some activity\n      ElementRemover.removeElement(mockElements[0], 'cleanup-test')\n      \n      let statsBeforeCleanup = ElementRemover.getStats()\n      expect(statsBeforeCleanup.removalStats.totalRemoved).toBe(1)\n      \n      const result = ElementRemover.cleanup()\n      \n      expect(result.success).toBe(true)\n      expect(result.stats.totalRemoved).toBe(1) // Should capture pre-cleanup stats\n      \n      const statsAfterCleanup = ElementRemover.getStats()\n      expect(statsAfterCleanup.removalStats.totalRemoved).toBe(0)\n    })\n    \n    it('should clear all callbacks on cleanup', () => {\n      const callback = vi.fn()\n      ElementRemover.onCleanup(callback)\n      \n      ElementRemover.cleanup()\n      \n      const stats = ElementRemover.getStats()\n      expect(stats.cleanupState.registeredCallbacks).toBe(0)\n    })\n    \n    it('should perform periodic cleanup checks', () => {\n      vi.useFakeTimers()\n      \n      // Trigger periodic cleanup check\n      ElementRemover.removeElement(mockElements[0], 'periodic-test')\n      \n      // Advance time to trigger auto-reset\n      vi.advanceTimersByTime(350000) // More than maxCacheAge\n      \n      // Next removal should trigger reset\n      ElementRemover.removeElement(mockElements[1], 'after-reset')\n      \n      // Stats should have been reset\n      const stats = ElementRemover.getStats()\n      expect(stats.removalStats.totalRemoved).toBe(1) // Only the last one\n      \n      vi.useRealTimers()\n    })\n  })\n  \n  describe('edge cases and error handling', () => {\n    it('should handle elements that become disconnected', () => {\n      const element = mockElements[0]\n      element.isConnected = false\n      \n      const result = ElementRemover.removeElement(element, 'disconnected-test')\n      \n      // Should still process even if disconnected\n      expect(result).toBe(true)\n    })\n    \n    it('should handle elements with frozen styles', () => {\n      const element = mockElements[0]\n      \n      // Freeze the style object\n      Object.freeze(element.style)\n      \n      // Should handle gracefully\n      expect(() => {\n        ElementRemover.removeElement(\n          element,\n          'frozen-test',\n          ElementRemover.REMOVAL_STRATEGIES.HIDE\n        )\n      }).not.toThrow()\n    })\n    \n    it('should handle very large batch operations', () => {\n      const largeArray = []\n      for (let i = 0; i < 1000; i++) {\n        largeArray.push(testUtils.createMockElement('div'))\n      }\n      \n      const result = ElementRemover.batchRemove(largeArray, 'large-batch')\n      \n      expect(result).toBe(1000)\n      \n      const stats = ElementRemover.getStats()\n      expect(stats.removalStats.totalRemoved).toBe(1000)\n    })\n  })\n})"