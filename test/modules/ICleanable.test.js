/**\n * Test suite for ICleanable interface and CleanupRegistry\n * Demonstrates comprehensive testing patterns for the cleanup system\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport {\n  LIFECYCLE_PHASES,\n  isCleanable,\n  isLifecycleAware,\n  analyzeCleanupNeeds,\n  CleanableModule,\n  CleanupRegistry\n} from '@modules/ICleanable.js'\n\ndescribe('ICleanable Interface', () => {\n  describe('isCleanable', () => {\n    it('should return true for objects with cleanup method', () => {\n      const cleanable = { cleanup: () => {} }\n      expect(isCleanable(cleanable)).toBe(true)\n    })\n    \n    it('should return false for objects without cleanup method', () => {\n      const notCleanable = { someOtherMethod: () => {} }\n      expect(isCleanable(notCleanable)).toBe(false)\n    })\n    \n    it('should return false for null or undefined', () => {\n      expect(isCleanable(null)).toBe(false)\n      expect(isCleanable(undefined)).toBe(false)\n    })\n  })\n  \n  describe('isLifecycleAware', () => {\n    it('should return true for fully lifecycle-aware objects', () => {\n      const lifecycleAware = {\n        cleanup: () => {},\n        onPhaseChange: () => {},\n        getLifecyclePhase: () => LIFECYCLE_PHASES.ACTIVE\n      }\n      expect(isLifecycleAware(lifecycleAware)).toBe(true)\n    })\n    \n    it('should return false for partially lifecycle-aware objects', () => {\n      const partial = {\n        cleanup: () => {},\n        onPhaseChange: () => {}\n        // missing getLifecyclePhase\n      }\n      expect(isLifecycleAware(partial)).toBe(false)\n    })\n  })\n  \n  describe('analyzeCleanupNeeds', () => {\n    it('should detect event listeners', () => {\n      const objWithListeners = {\n        eventListeners: ['click', 'scroll'],\n        _listeners: new Map()\n      }\n      \n      const analysis = analyzeCleanupNeeds(objWithListeners)\n      expect(analysis.hasEventListeners).toBe(true)\n      expect(analysis.recommendations).toContain('Remove event listeners in cleanup()')\n    })\n    \n    it('should detect timers', () => {\n      const objWithTimers = {\n        timerId: 123,\n        intervalId: 456\n      }\n      \n      const analysis = analyzeCleanupNeeds(objWithTimers)\n      expect(analysis.hasTimers).toBe(true)\n      expect(analysis.recommendations).toContain('Clear timers/intervals in cleanup()')\n    })\n    \n    it('should calculate risk level correctly', () => {\n      const highRiskObj = {\n        eventListeners: ['click'],\n        timerId: 123,\n        observer: {},\n        pendingPromises: []\n      }\n      \n      const analysis = analyzeCleanupNeeds(highRiskObj)\n      expect(analysis.riskLevel).toBe('high')\n    })\n    \n    it('should handle null objects gracefully', () => {\n      const analysis = analyzeCleanupNeeds(null)\n      expect(analysis.riskLevel).toBe('low')\n      expect(analysis.recommendations).toHaveLength(0)\n    })\n  })\n})\n\ndescribe('CleanableModule', () => {\n  let module\n  \n  beforeEach(() => {\n    module = new CleanableModule()\n  })\n  \n  afterEach(() => {\n    if (module && typeof module.cleanup === 'function') {\n      module.cleanup()\n    }\n  })\n  \n  it('should initialize with correct lifecycle phase', () => {\n    expect(module.getLifecyclePhase()).toBe(LIFECYCLE_PHASES.INITIALIZING)\n  })\n  \n  it('should change lifecycle phases correctly', () => {\n    const phaseChanges = []\n    module.onPhaseChange((newPhase, oldPhase) => {\n      phaseChanges.push({ newPhase, oldPhase })\n    })\n    \n    module.setLifecyclePhase(LIFECYCLE_PHASES.ACTIVE)\n    \n    expect(phaseChanges).toHaveLength(1)\n    expect(phaseChanges[0].newPhase).toBe(LIFECYCLE_PHASES.ACTIVE)\n    expect(phaseChanges[0].oldPhase).toBe(LIFECYCLE_PHASES.INITIALIZING)\n  })\n  \n  it('should notify multiple lifecycle listeners', () => {\n    const listener1 = vi.fn()\n    const listener2 = vi.fn()\n    \n    module.onPhaseChange(listener1)\n    module.onPhaseChange(listener2)\n    \n    module.setLifecyclePhase(LIFECYCLE_PHASES.ACTIVE)\n    \n    expect(listener1).toHaveBeenCalledWith(\n      LIFECYCLE_PHASES.ACTIVE,\n      LIFECYCLE_PHASES.INITIALIZING,\n      module\n    )\n    expect(listener2).toHaveBeenCalledWith(\n      LIFECYCLE_PHASES.ACTIVE,\n      LIFECYCLE_PHASES.INITIALIZING,\n      module\n    )\n  })\n  \n  it('should handle listener errors gracefully', () => {\n    const faultyListener = vi.fn(() => {\n      throw new Error('Listener error')\n    })\n    const goodListener = vi.fn()\n    \n    module.onPhaseChange(faultyListener)\n    module.onPhaseChange(goodListener)\n    \n    // Should not throw despite faulty listener\n    expect(() => {\n      module.setLifecyclePhase(LIFECYCLE_PHASES.ACTIVE)\n    }).not.toThrow()\n    \n    expect(goodListener).toHaveBeenCalled()\n  })\n  \n  it('should remove phase change listeners correctly', () => {\n    const listener = vi.fn()\n    \n    module.onPhaseChange(listener)\n    module.offPhaseChange(listener)\n    module.setLifecyclePhase(LIFECYCLE_PHASES.ACTIVE)\n    \n    expect(listener).not.toHaveBeenCalled()\n  })\n  \n  it('should track lifecycle statistics', () => {\n    module.setLifecyclePhase(LIFECYCLE_PHASES.ACTIVE)\n    const stats = module.getLifecycleStats()\n    \n    expect(stats.currentPhase).toBe(LIFECYCLE_PHASES.ACTIVE)\n    expect(stats.lastPhaseChange).toBeTypeOf('number')\n    expect(stats.timeSinceLastChange).toBeTypeOf('number')\n    expect(stats.listenersCount).toBe(0)\n  })\n  \n  it('should set correct phase during cleanup', () => {\n    module.initialize()\n    expect(module.getLifecyclePhase()).toBe(LIFECYCLE_PHASES.ACTIVE)\n    \n    module.cleanup()\n    expect(module.getLifecyclePhase()).toBe(LIFECYCLE_PHASES.CLEANED)\n  })\n})\n\ndescribe('CleanupRegistry', () => {\n  let registry\n  \n  beforeEach(() => {\n    registry = new CleanupRegistry({\n      maxCompartmentSize: 5,\n      compartmentTTL: 1000,\n      cleanupInterval: 100,\n      enablePeriodicCleanup: false // Disable for testing\n    })\n  })\n  \n  afterEach(() => {\n    if (registry) {\n      registry.cleanup()\n    }\n  })\n  \n  describe('module registration', () => {\n    it('should register cleanable modules successfully', () => {\n      const module = { cleanup: vi.fn() }\n      const result = registry.register(module, 'test-module', 'test-compartment')\n      \n      expect(result).toBe(true)\n      expect(registry.getModuleCount()).toBe(1)\n      expect(registry.getModuleNames()).toContain('test-module')\n    })\n    \n    it('should reject non-cleanable modules', () => {\n      const module = { someMethod: () => {} }\n      const result = registry.register(module, 'invalid-module')\n      \n      expect(result).toBe(false)\n      expect(registry.getModuleCount()).toBe(0)\n    })\n    \n    it('should track cleanup analysis for registered modules', () => {\n      const module = {\n        cleanup: vi.fn(),\n        eventListeners: ['click', 'scroll'],\n        timerId: 123\n      }\n      \n      registry.register(module, 'risky-module', 'test')\n      const stats = registry.getMemoryStats()\n      \n      expect(stats.totalMemoryRisk).toBeGreaterThan(0)\n    })\n  })\n  \n  describe('compartment management', () => {\n    it('should create compartments automatically', () => {\n      const module = { cleanup: vi.fn() }\n      registry.register(module, 'test', 'new-compartment')\n      \n      const stats = registry.getMemoryStats()\n      expect(stats.compartments['new-compartment']).toBeDefined()\n    })\n    \n    it('should enforce compartment size limits', () => {\n      // Register modules up to limit\n      for (let i = 0; i < 6; i++) {\n        const module = { cleanup: vi.fn() }\n        registry.register(module, `module-${i}`, 'limited-compartment')\n      }\n      \n      // Should have enforced limit (5) by removing oldest\n      const stats = registry.getMemoryStats()\n      expect(stats.compartments['limited-compartment'].moduleCount).toBe(5)\n    })\n    \n    it('should clean up specific compartments', () => {\n      const modules = []\n      for (let i = 0; i < 3; i++) {\n        const module = { cleanup: vi.fn() }\n        modules.push(module)\n        registry.register(module, `module-${i}`, 'test-compartment')\n      }\n      \n      const result = registry.cleanupCompartment('test-compartment')\n      \n      expect(result.cleaned).toBe(3)\n      expect(result.errors).toBe(0)\n      modules.forEach(module => {\n        expect(module.cleanup).toHaveBeenCalled()\n      })\n    })\n  })\n  \n  describe('cleanup operations', () => {\n    it('should clean up all modules with priority ordering', async () => {\n      const highPriorityModule = { \n        cleanup: vi.fn(),\n        metadata: { priority: 'high' }\n      }\n      const normalModule = { \n        cleanup: vi.fn(),\n        metadata: { priority: 'normal' }\n      }\n      \n      registry.register(normalModule, 'normal', 'default', { priority: 'normal' })\n      registry.register(highPriorityModule, 'high', 'default', { priority: 'high' })\n      \n      const results = registry.cleanupAll()\n      \n      expect(results).toHaveLength(2)\n      expect(results.every(r => r.success)).toBe(true)\n      expect(highPriorityModule.cleanup).toHaveBeenCalled()\n      expect(normalModule.cleanup).toHaveBeenCalled()\n    })\n    \n    it('should handle cleanup errors gracefully', () => {\n      const faultyModule = {\n        cleanup: vi.fn(() => {\n          throw new Error('Cleanup failed')\n        })\n      }\n      const goodModule = { cleanup: vi.fn() }\n      \n      registry.register(faultyModule, 'faulty')\n      registry.register(goodModule, 'good')\n      \n      const results = registry.cleanupAll()\n      \n      expect(results).toHaveLength(2)\n      expect(results.find(r => r.name === 'faulty').success).toBe(false)\n      expect(results.find(r => r.name === 'good').success).toBe(true)\n    })\n    \n    it('should calculate health score correctly', () => {\n      // Register some modules with different risk levels\n      const lowRisk = { cleanup: vi.fn() }\n      const highRisk = {\n        cleanup: vi.fn(),\n        eventListeners: ['click'],\n        timerId: 123,\n        observer: {}\n      }\n      \n      registry.register(lowRisk, 'low-risk')\n      registry.register(highRisk, 'high-risk')\n      \n      const stats = registry.getMemoryStats()\n      expect(stats.healthScore).toBeTypeOf('number')\n      expect(stats.healthScore).toBeGreaterThanOrEqual(0)\n      expect(stats.healthScore).toBeLessThanOrEqual(100)\n    })\n  })\n  \n  describe('lifecycle awareness integration', () => {\n    it('should monitor lifecycle-aware modules', () => {\n      const lifecycleModule = new CleanableModule()\n      lifecycleModule.initialize()\n      \n      registry.register(lifecycleModule, 'lifecycle-test')\n      \n      const stats = registry.getMemoryStats()\n      expect(stats.totalLifecycleAware).toBe(1)\n      expect(stats.phaseDistribution[LIFECYCLE_PHASES.ACTIVE]).toBe(1)\n    })\n    \n    it('should handle lifecycle phase changes', async () => {\n      const lifecycleModule = new CleanableModule()\n      lifecycleModule.initialize()\n      \n      // Mock auto-cleanup behavior\n      const originalRegister = registry.register.bind(registry)\n      registry.register = vi.fn((module, name, compartment, options) => {\n        const result = originalRegister(module, name, compartment, options)\n        \n        if (isLifecycleAware(module)) {\n          module.onPhaseChange((newPhase) => {\n            if (newPhase === LIFECYCLE_PHASES.ERROR && options?.autoCleanup) {\n              setTimeout(() => {\n                try {\n                  module.cleanup()\n                } catch (e) {\n                  // Cleanup error handled\n                }\n              }, 1)\n            }\n          })\n        }\n        \n        return result\n      })\n      \n      registry.register(lifecycleModule, 'auto-cleanup', 'default', { autoCleanup: true })\n      \n      // Trigger error phase\n      lifecycleModule.setLifecyclePhase(LIFECYCLE_PHASES.ERROR)\n      \n      // Wait for auto-cleanup\n      await testUtils.nextTick()\n      \n      expect(lifecycleModule.getLifecyclePhase()).toBe(LIFECYCLE_PHASES.CLEANED)\n    })\n  })\n})"